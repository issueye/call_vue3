# 新旧版功能对比与完善方案

## 文档信息

| 项目 | 内容 |
|------|------|
| 文档名称 | 新旧版功能对比与完善方案 |
| 文档版本 | v1.0.0 |
| 编写日期 | 2026-01-07 |
| 对比对象 | vue3(old) vs frontend (新版) |

---

## 一、功能对比总览

### 1.1 功能对比表

| 功能模块 | 旧版 (vue3/old) | 新版 (frontend) | 差异说明 |
|----------|----------------|-----------------|----------|
| **呼叫患者** | ✅ 完整 | ✅ 完整 | 无差异 |
| **重呼患者** | ✅ 完整 | ⚠️ 部分实现 | 新版缺少专门的"重呼"方法 |
| **下一位** | ✅ 智能判断 | ⚠️ 基础实现 | 新版缺少首次进入标记和智能判断 |
| **过号** | ✅ 完整 | ✅ 完整 | 无差异 |
| **结诊** | ✅ 完整 | ✅ 完整 | 无差异 |
| **分诊弹窗** | ✅ 完整 | ⚠️ 部分实现 | 新版缺少完整的分诊流程 |
| **医生开诊/停诊** | ✅ 完整 | ✅ 完整 | 无差异 |
| **转诊功能** | ✅ 完整 | ✅ 完整 | 无差异 |
| **MQTT实时同步** | ✅ 完整 | ⚠️ 待实现 | 新版需要完善MQTT集成 |
| **语音播报** | ✅ 完整 | ⚠️ 待实现 | 新版需要集成语音播报 |

### 1.2 架构对比

| 维度 | 旧版 | 新版 | 评价 |
|------|------|------|------|
| **代码组织** | Composables + 分离 | Stores + 组件 | 新版更规范 |
| **状态管理** | Pinia | Pinia | 相同 |
| **组件设计** | 响应式分离组件 | 统一组件 + 响应式CSS | 新版更优 |
| **类型安全** | JavaScript | JavaScript | 可升级到TypeScript |
| **错误处理** | try-catch + ElMessage | try-catch | 相同 |

---

## 二、功能差异详解

### 2.1 重呼功能

#### 2.1.1 旧版实现

**代码位置：** `vue3(old)/src/pages/workbench/composables/useLeft.js`

```javascript
// 重呼调用
const callPatient = async (type) => {
  const params = {
    appointment_id: type === 'recall'
      ? currentCall.value?.appointment_id  // 重呼时传当前患者ID
      : "",                                 // 首次呼叫为空
    dept_id: null,
    room_id: null,
    doc_id: userStore.userInfo.id,
  };

  const info = await getCallerInstance().apis.triage.apiPatCall(params);
  triageStore.setCurrentCall(info.data);
  updateInfos(info.data);
};
```

**特点：**
- 通过 `type === 'recall'` 区分重呼和首次呼叫
- 重呼时传递 `appointment_id`
- 自动更新呼叫次数

#### 2.1.2 新版现状

**代码位置：** `frontend/src/stores/patient.js`

```javascript
// 方法 - 呼叫患者
const callPatient = async (docId, patient) => {
  try {
    const params = {
      appointment_id: "",  // 固定为空，无法区分重呼
      dept_id: null,
      room_id: null,
      doc_id: docId,
    };
    const callRes = await apiPatCall(params);
    // ...
  }
};
```

**问题：**
- ❌ 没有专门的 `recallPatient` 方法
- ❌ `appointment_id` 固定为空，无法重呼当前患者
- ❌ 没有区分首次呼叫和重呼的逻辑

#### 2.1.3 完善方案

```javascript
// 新增：重呼患者方法
const recallPatient = async (docId, patient) => {
  try {
    // 如果没有指定患者，重呼当前在诊患者
    const targetPatient = patient || visitPatient.value || currentCall.value;

    if (!targetPatient?.appointment_id) {
      return { success: false, message: "无在诊患者，无法重呼" };
    }

    const params = {
      appointment_id: targetPatient.appointment_id,
      dept_id: null,
      room_id: null,
      doc_id: docId,
    };

    const callRes = await apiPatCall(params);

    // 更新呼叫次数
    if (targetPatient.call_count !== undefined) {
      targetPatient.call_count += 1;
    } else if (targetPatient.callTimes !== undefined) {
      targetPatient.callTimes += 1;
    }

    return { success: true, data: callRes };
  } catch (error) {
    console.error("重呼患者失败:", error);
    return { success: false, message: error.message || "重呼失败" };
  }
};
```

---

### 2.2 下一位智能判断

#### 2.2.1 旧版实现

**代码位置：** `vue3(old)/src/pages/workbench/composables/useLeft.js`

```javascript
// 首次进入标记
const isFirstEnter = ref(true);

const handleNextClick = async () => {
  // 智能判断：首次进入直接呼叫
  if ((isFirstEnter.value && Object.keys(currentCall.value).length == 0) ||
      !currentCall.value) {
    callPatient();
    isFirstEnter.value = false;
    return;
  }

  // 非首次，显示分诊弹窗
  showNextDoctor.value = true;
  triageForm.value = currentCall.value;
  await getDeptList();
};
```

**特点：**
- ✅ `isFirstEnter` 标记首次进入
- ✅ 检查 `currentCall` 是否有在诊患者
- ✅ 首次直接呼叫，非首次显示分诊弹窗
- ✅ 用户体验友好

#### 2.2.2 新版现状

**代码位置：** `frontend/src/stores/patient.js`

```javascript
// 方法 - 下一位
const handleNext = async (docId, orgId, deptId) => {
  if (!visitPatient.value) {
    // 首次呼叫
    if (waitingPatients.value.length > 0) {
      const nextPatient = waitingPatients.value[0];
      const result = await callPatient(docId, nextPatient);
      if (result.success) {
        visitPatient.value = nextPatient;
        isFirstCall.value = false;
      }
      return result;
    }
  } else {
    // 有在诊患者，弹出选择框
    showNextDialog.value = true;
    // 获取可分配诊室
    await getDeptRoomList(orgId, deptId);
  }
  return { success: false };
};
```

**问题：**
- ⚠️ 有 `isFirstCall` 状态，但逻辑不够完善
- ⚠️ 没有在应用启动时初始化
- ⚠️ `handleNext` 依赖外部传入参数，不够智能

#### 2.2.3 完善方案

**1. 初始化 isFirstCall 状态**

```javascript
// 在应用启动时初始化
onMounted(() => {
  // 获取在诊患者
  await getVisitedPatient(userStore.userInfo.id);

  // 如果没有在诊患者，说明是首次进入
  if (!visitPatient.value) {
    isFirstCall.value = true;
  }
});
```

**2. 优化 handleNext 方法**

```javascript
const handleNext = async (docId, orgId, deptId) => {
  // 首次呼叫或无在诊患者
  if (!visitPatient.value || isFirstCall.value) {
    if (waitingPatients.value.length > 0) {
      const nextPatient = waitingPatients.value[0];
      const result = await callPatient(docId, nextPatient);

      if (result.success) {
        visitPatient.value = nextPatient;
        isFirstCall.value = false;  // 更新首次呼叫标记
      }

      return result;
    } else {
      return { success: false, message: "暂无候诊患者" };
    }
  }

  // 有在诊患者，显示分诊选择
  showNextDialog.value = true;
  await getDeptRoomList(orgId, deptId);

  return { success: false, message: "请先处理当前在诊患者" };
};
```

---

### 2.3 分诊弹窗完整流程

#### 2.3.1 旧版实现

**代码位置：** `vue3(old)/src/pages/workbench/left/index.vue`

```vue
<el-dialog
  v-model="showNextDoctor"
  title="分诊"
  width="500px"
>
  <!-- 当前患者信息 -->
  <div class="current-patient">
    <span>当前患者：{{ triageForm.name }}</span>
    <span>排队号：{{ triageForm.queueNo }}</span>
  </div>

  <!-- 转诊选项 -->
  <div v-if="roomList.length > 0" class="triage-options">
    <el-form>
      <el-form-item label="转到其他诊室">
        <el-select v-model="selectedRoom" placeholder="请选择诊室">
          <el-option
            v-for="room in roomList"
            :key="room.id"
            :label="room.name"
            :value="room.id"
          />
        </el-select>
      </el-form-item>
    </el-form>
  </div>

  <!-- 操作按钮 -->
  <div class="triage-actions">
    <!-- 转诊按钮（有诊室可选） -->
    <el-button
      v-if="roomList.length > 0"
      type="primary"
      :loading="sureLoading"
      @click="confirmAssign"
    >
      确认转诊
    </el-button>

    <!-- 结诊按钮 -->
    <el-button
      type="success"
      :loading="sureLoading"
      @click="endServer"
    >
      结诊
    </el-button>

    <!-- 取消按钮 -->
    <el-button @click="showNextDoctor = false">
      取消
    </el-button>
  </div>
</el-dialog>
```

**特点：**
- ✅ 显示当前患者信息
- ✅ 支持转诊到其他诊室
- ✅ 支持结诊
- ✅ 有加载状态
- ✅ 有取消按钮

#### 2.3.2 新版现状

**代码位置：** 需要创建分诊弹窗组件

**问题：**
- ❌ 没有独立的分诊弹窗组件
- ❌ 没有显示当前患者信息
- ❌ 没有转诊选项
- ❌ 没有加载状态

#### 2.3.3 完善方案

**创建分诊弹窗组件：** `frontend/src/components/common/TriageDialog.vue`

```vue
<script setup>
import { ref, computed, watch } from "vue";
import { usePatientStore } from "@/stores";
import "./TriageDialog.css";

const props = defineProps({
  visible: {
    type: Boolean,
    default: false,
  },
  patient: {
    type: Object,
    default: null,
  },
  roomList: {
    type: Array,
    default: () => [],
  },
});

const emit = defineEmits(["update:visible", "triage", "end", "cancel"]);

const patientStore = usePatientStore();
const selectedRoom = ref(null);
const loading = ref(false);

// 监听弹窗打开，重置选择
watch(() => props.visible, (val) => {
  if (val) {
    selectedRoom.value = null;
  }
});

// 确认转诊
const handleTriage = async () => {
  if (!selectedRoom.value) {
    alert("请选择诊室");
    return;
  }

  loading.value = true;
  try {
    await emit("triage", props.patient, selectedRoom.value);
    emit("update:visible", false);
  } finally {
    loading.value = false;
  }
};

// 确认结诊
const handleEnd = async () => {
  loading.value = true;
  try {
    await emit("end", props.patient);
    emit("update:visible", false);
  } finally {
    loading.value = false;
  }
};

// 取消
const handleCancel = () => {
  selectedRoom.value = null;
  emit("update:visible", false);
  emit("cancel");
};
</script>

<template>
  <Teleport to="body">
    <Transition name="dialog-fade">
      <div
        v-if="visible"
        class="triage-dialog-overlay"
        @click.self="handleCancel"
      >
        <Transition name="dialog-slide">
          <div v-if="visible" class="triage-dialog">
            <!-- 标题 -->
            <div class="triage-dialog__header">
              <h3 class="triage-dialog__title">患者分诊</h3>
              <button
                class="triage-dialog__close"
                @click="handleCancel"
              >
                ×
              </button>
            </div>

            <!-- 内容 -->
            <div class="triage-dialog__body">
              <!-- 当前患者信息 -->
              <div v-if="patient" class="triage-dialog__patient-info">
                <div class="patient-avatar">
                  {{ patient.name?.charAt(0) || "?" }}
                </div>
                <div class="patient-details">
                  <div class="patient-name">{{ patient.name }}</div>
                  <div class="patient-meta">
                    <span class="queue-no">{{ patient.queueNo }}</span>
                    <span class="divider">|</span>
                    <span class="call-count">
                      呼叫 {{ patient.call_count || patient.callTimes || 0 }} 次
                    </span>
                  </div>
                </div>
              </div>

              <!-- 转诊选项 -->
              <div v-if="roomList.length > 0" class="triage-dialog__options">
                <div class="option-title">
                  <span class="icon">🏥</span>
                  转到其他诊室
                </div>
                <div class="room-selector">
                  <select v-model="selectedRoom" class="room-select">
                    <option value="">请选择诊室</option>
                    <option
                      v-for="room in roomList"
                      :key="room.id"
                      :value="room.id"
                    >
                      {{ room.name }}
                    </option>
                  </select>
                </div>
              </div>
            </div>

            <!-- 底部按钮 -->
            <div class="triage-dialog__footer">
              <!-- 转诊按钮 -->
              <button
                v-if="roomList.length > 0"
                class="btn btn--triage"
                :disabled="!selectedRoom || loading"
                @click="handleTriage"
              >
                <span v-if="!loading">确认转诊</span>
                <span v-else>处理中...</span>
              </button>

              <!-- 结诊按钮 -->
              <button
                class="btn btn--end"
                :disabled="loading"
                @click="handleEnd"
              >
                <span v-if="!loading">结诊</span>
                <span v-else>处理中...</span>
              </button>

              <!-- 取消按钮 -->
              <button
                class="btn btn--cancel"
                :disabled="loading"
                @click="handleCancel"
              >
                取消
              </button>
            </div>
          </div>
        </Transition>
      </div>
    </Transition>
  </Teleport>
</template>
```

---

## 三、功能完善清单

### 3.1 高优先级（必须实现）

| 序号 | 功能 | 说明 | 文件位置 |
|------|------|------|----------|
| 1 | **重呼功能** | 添加 `recallPatient` 方法 | `stores/patient.js` |
| 2 | **下一位智能判断** | 优化 `handleNext` 逻辑 | `stores/patient.js` |
| 3 | **分诊弹窗组件** | 创建完整的分诊弹窗 | `components/common/TriageDialog.vue` |
| 4 | **首次进入标记** | 初始化 `isFirstCall` 状态 | 工作台初始化逻辑 |
| 5 | **呼叫按钮组件** | 创建完整的呼叫按钮组 | `components/business/CallButtons.vue` |

### 3.2 中优先级（建议实现）

| 序号 | 功能 | 说明 | 文件位置 |
|------|------|------|----------|
| 6 | **MQTT集成** | 实时同步患者状态 | `mqtt/` |
| 7 | **语音播报** | 呼叫时播放语音 | `utils/voice.js` |
| 8 | **操作确认** | 危险操作二次确认 | 对话框组件 |
| 9 | **错误提示优化** | 统一错误处理 | `utils/error.js` |
| 10 | **加载状态** | 操作进行中提示 | Loading组件 |

### 3.3 低优先级（可选实现）

| 序号 | 功能 | 说明 |
|------|------|------|
| 11 | 快捷键支持 | 空格呼叫、R重呼等 |
| 12 | 操作历史 | 记录操作日志 |
| 13 | 撤销功能 | 支持撤销操作 |
| 14 | 批量操作 | 批量过号、结诊 |

---

## 四、实施计划

### 4.1 第一阶段：核心功能完善

**目标：** 实现基本的呼叫、重呼、下一位功能

1. ✅ 添加 `recallPatient` 方法
2. ✅ 优化 `handleNext` 智能判断
3. ✅ 创建 `CallButtons` 组件
4. ✅ 完善患者详情卡片

### 4.2 第二阶段：分诊流程

**目标：** 实现完整的分诊弹窗和流程

1. ✅ 创建 `TriageDialog` 组件
2. ✅ 实现转诊功能
3. ✅ 完善结诊功能
4. ✅ 添加加载状态

### 4.3 第三阶段：用户体验优化

**目标：** 提升用户体验和系统稳定性

1. ✅ 添加操作确认对话框
2. ✅ 优化错误提示
3. ✅ 添加加载动画
4. ✅ 完善边界条件处理

### 4.4 第四阶段：高级功能

**目标：** 实现实时同步和语音播报

1. ✅ MQTT 实时同步
2. ✅ 语音播报集成
3. ✅ 快捷键支持
4. ✅ 操作历史记录

---

## 五、代码实现参考

### 5.1 CallButtons 组件

```vue
<script setup>
import { computed } from "vue";
import { usePatientStore } from "@/stores";
import "./CallButtons.css";

const props = defineProps({
  patient: {
    type: Object,
    default: null,
  },
});

const emit = defineEmits(["next", "recall", "skip"]);

const patientStore = usePatientStore();

// 是否有在诊患者
const hasVisitPatient = computed(() => !!patientStore.visitPatient);

// 是否可以重呼
const canRecall = computed(() => {
  return hasVisitPatient.value || props.patient;
});
</script>

<template>
  <div class="call-buttons">
    <!-- 呼叫下一位 -->
    <button
      class="btn btn--call"
      @click="emit('next')"
    >
      <svg class="icon" viewBox="0 0 24 24">
        <path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/>
      </svg>
      <span>下一位</span>
    </button>

    <!-- 重呼 -->
    <button
      class="btn btn--recall"
      :disabled="!canRecall"
      @click="emit('recall')"
    >
      <svg class="icon" viewBox="0 0 24 24">
        <path d="M12.5 2C6.81 2 2 6.81 2 12.5S6.81 23 12.5 23 23 18.19 23 12.5 18.19 2 12.5 2zm0 2c4.56 0 8.25 3.69 8.25 8.25h-2.5c0-3.17-2.58-5.75-5.75-5.75V4zm0 5.5c1.66 0 3 1.34 3 3h-2c0-.55-.45-1-1-1v-2z"/>
      </svg>
      <span>重呼</span>
    </button>

    <!-- 过号 -->
    <button
      class="btn btn--skip"
      @click="emit('skip')"
    >
      <svg class="icon" viewBox="0 0 24 24">
        <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
      </svg>
      <span>过号</span>
    </button>
  </div>
</template>
```

### 5.2 更新 DesktopLayout

```vue
<script setup>
import { computed } from "vue";
import { usePatientStore, useUserStore } from "@/stores";
import { PatientList } from "@/components/business";
import CallButtons from "@/components/business/CallButtons.vue";
import PatientDetailDialog from "@/components/common/PatientDetailDialog.vue";
import DesktopPatientDetailCard from "./desktop/PatientDetailCard.vue";
import "./DesktopLayout.css";

const patientStore = usePatientStore();
const userStore = useUserStore();

const handleSelect = (patient) => {
  patientStore.setCurrentPatient(patient);
};

const handleCall = (patient) => {
  patientStore.callPatient(userStore.userInfo.id, patient);
};

const handleRecall = (patient) => {
  patientStore.recallPatient(userStore.userInfo.id, patient);
};

const handleSkip = (patient) => {
  patientStore.skipPatient(userStore.userInfo.id, patient);
};

const handleDetail = (patient) => {
  patientStore.openDetailDialog(patient);
};

const handleNext = async () => {
  await patientStore.handleNext(
    userStore.userInfo.id,
    userStore.org.org_id,
    userStore.room.dept_id || userStore.org.dept_id
  );
};
</script>

<template>
  <div class="desktop-layout">
    <div class="desktop-layout__left">
      <PatientList
        :active-id="patientStore.currentPatient?.id"
        :loading="patientStore.loading"
        @select="handleSelect"
        @call="handleCall"
        @detail="handleDetail"
      />
    </div>

    <div class="desktop-layout__right">
      <!-- 患者详情卡片 -->
      <DesktopPatientDetailCard
        :patient="patientStore.currentPatient"
        @next="handleNext"
        @recall="handleRecall"
        @skip="handleSkip"
      />

      <!-- 呼叫按钮组 -->
      <CallButtons
        v-if="patientStore.currentPatient"
        :patient="patientStore.currentPatient"
        @next="handleNext"
        @recall="handleRecall"
        @skip="handleSkip"
      />
    </div>

    <!-- 患者详情弹窗 -->
    <PatientDetailDialog
      v-model:visible="patientStore.showDetailDialog"
      :patient="patientStore.dialogPatient"
      @close="patientStore.closeDetailDialog"
    />
  </div>
</template>
```

---

## 六、测试计划

### 6.1 功能测试

| 测试项 | 操作步骤 | 预期结果 |
|--------|----------|----------|
| 呼叫患者 | 点击"呼叫"按钮 | 成功呼叫第一位患者 |
| 重呼患者 | 点击"重呼"按钮 | 重新呼叫当前患者 |
| 下一位（首次） | 首次点击"下一位" | 直接呼叫，不显示分诊弹窗 |
| 下一位（有在诊） | 有在诊时点击"下一位" | 显示分诊弹窗 |
| 分诊-转诊 | 选择诊室并确认转诊 | 成功转诊，从列表移除 |
| 分诊-结诊 | 点击"结诊"按钮 | 成功结诊，自动呼叫下一位 |
| 过号 | 点击"过号"按钮 | 患者状态变为过号 |

### 6.2 边界测试

| 测试项 | 测试场景 | 预期结果 |
|--------|----------|----------|
| 空队列 | 无患者时呼叫 | 提示"暂无患者" |
| 无在诊患者重呼 | 无患者时点击重呼 | 按钮禁用或提示 |
| 重复操作 | 快速重复点击 | 只执行一次 |
| 网络错误 | 断网时操作 | 提示网络错误 |

---

## 七、总结

### 7.1 关键差异

1. **重呼功能缺失**：新版没有专门的 `recallPatient` 方法
2. **智能判断不完善**：新版缺少首次进入标记的初始化
3. **分诊弹窗不完整**：新版需要创建完整的分诊弹窗组件

### 7.2 实施建议

1. **优先级排序**：先实现高优先级功能
2. **分阶段实施**：按四个阶段逐步完善
3. **测试驱动**：每完成一个功能立即测试
4. **保持兼容**：不破坏现有功能

### 7.3 后续优化

1. 添加 TypeScript 支持
2. 完善单元测试
3. 优化性能
4. 增加操作日志

---

**文档结束**
